from pynput import keyboard
from Quartz import CGEventCreateKeyboardEvent, CGEventPost, kCGHIDEventTap
import time
import random

# macOS Key Codes for delete + all letters & digits
KEY_DELETE = 51
KEY_CODE_MAP = {
    # letters
    'a': 0,  'b': 11, 'c': 8,  'd': 2,  'e': 14,
    'f': 3,  'g': 5,  'h': 4,  'i': 34, 'j': 38,
    'k': 40, 'l': 37, 'm': 46, 'n': 45, 'o': 31,
    'p': 35, 'q': 12, 'r': 15, 's': 1,  't': 17,
    'u': 32, 'v': 9,  'w': 13, 'x': 7,  'y': 16,
    'z': 6,
    # digits
    '0': 29, '1': 18, '2': 19, '3': 20, '4': 21,
    '5': 23, '6': 22, '7': 26, '8': 28, '9': 25,
}

# 10% chance per key-release
PROBABILITY = 0.1

def human_delay():
    time.sleep(random.uniform(0.001, 0.03))

def inject_delete_and_retype(char, key_code):
    """Delete the original char and then re-type it."""
    print(f"Re-injecting '{char}' (code {key_code})")
    
    # build events
    delete_down = CGEventCreateKeyboardEvent(None, KEY_DELETE, True)
    delete_up   = CGEventCreateKeyboardEvent(None, KEY_DELETE, False)
    char_down   = CGEventCreateKeyboardEvent(None, key_code, True)
    char_up     = CGEventCreateKeyboardEvent(None, key_code, False)
    
    # play them back with human-like delays
    human_delay()
    CGEventPost(kCGHIDEventTap, delete_down)
    human_delay()
    CGEventPost(kCGHIDEventTap, char_down)
    human_delay()
    CGEventPost(kCGHIDEventTap, delete_up)
    human_delay()
    CGEventPost(kCGHIDEventTap, char_up)
    
    print(f"Done re-injecting '{char}'")

def on_release(key):
    # Safe-get the character (might be None)
    ch = getattr(key, 'char', None)
    # Only proceed if it's a single alphanumeric char we have a code for
    if isinstance(ch, str) and ch.lower() in KEY_CODE_MAP:
        if random.random() < PROBABILITY:
            key_code = KEY_CODE_MAP[ch.lower()]
            inject_delete_and_retype(ch, key_code)

if __name__ == "__main__":
    print(f"Waiting for letters/digitsâ€¦ (each has a {PROBABILITY*100:.0f}% chance to get deleted+retyped)")
    with keyboard.Listener(on_release=on_release) as listener:
        listener.join()
